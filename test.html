<html>
	<head>
		<meta charset="UTF-8">
		<style>
			* { margin:0; padding:0; } /* to remove the top and left whitespace */

			html, body { width:100%; height:100%; } /* just to be sure these are full screen*/

			canvas { display:block; position: absolute; left: 0; top:0;} /* To remove the scrollbars */
			#gridCanvas { z-index: 1; background: #262626;};
			#mainCanvas { z-index: 2;};
			#container {overflow: auto};
		</style>
		<script src="/js/svg.js"></script>
		<script src="/js/svg.filter.js"></script>
		<script src="/js/jsface.js"></script>
		<script src="/js/app/SVG.js"></script>
		<script src="/js/app/Canvases/AbstractCanvas.js"></script>
		<script src="/js/app/Canvases/EventCanvas.js"></script>
		<script src="/js/app/Canvases/GridCanvas.js"></script>
		<script src="/js/app/Canvases/HoverCanvas.js"></script>
		<script src="/js/app/Canvases/LinksCanvas.js"></script>
		<script src="/js/app/Canvases/NodesCanvas.js"></script>
		
		
		<script src="/js/app/Globals.js"></script>
		<script src="/js/app/BPParser.js"></script>
		<script src="/js/app/Nodes/AbstractNode.js"></script>
		<script src="/js/app/Nodes/FunctionNode.js"></script>
		<script src="/js/app/Nodes/GetterNode.js"></script>
		<script src="/js/app/Nodes/SetterNode.js"></script>
		<script src="/js/app/Nodes/EventNode.js"></script>
		<script src="/js/app/Nodes/ConverterNode.js"></script>
		<script src="/js/app/Nodes/BinaryOperatorNode.js"></script>
		<script src="/js/app/Nodes/MacroNode.js"></script>
	</head>
	<body style="overflow: hidden">


		<div id="container">
			<canvas id="gridCanvas" style="z-index: 1;"></canvas>
			<canvas id="linksCanvas" style="z-index: 2;"></canvas>
			<canvas id="shadowCanvas" style="z-index: 3;"></canvas>
			<canvas id="mainCanvas"  style="z-index: 5;"></canvas>
			<canvas id="hoverCanvas"  style="z-index: 4;"></canvas>
			<canvas id="eventCanvas"  style="z-index: 99;"></canvas>
		</div>

		<script>
			window.addEventListener("load", onLoad, false);
			window.addEventListener('resize', onResize, true);
			window.addEventListener('paste', onPaste, true);
			var objects = [];
			var nodes = [];

			function onResize() {
				//globalStack.resizeAll();
			}

			function onPaste(e) {
				var content;

				e.preventDefault();

				console.log(e);
			}

			function getRandomInt(min, max) {
				return Math.floor(Math.random() * (max - min)) + min;
			}
			function onLoad()
			{
				var client = new XMLHttpRequest();
				client.open('GET', '/file.txt');
				client.onreadystatechange = function () {
					if (client.readyState === 4 && client.status === 200)
					{
						if (client.responseText)
							parse(client.responseText);
					}
				}
				client.send();

			}

			function draw() {
				var minX, minY;
				minX = objects[0].nodePosX;
				minY = objects[0].nodePosY;

				var mainCan = new NodesCanvas('mainCanvas', nodes);
				var gridCan = new GridCanvas('gridCanvas');
				var hoverCan = new HoverCanvas('hoverCanvas', nodes);
				var linksCan = new LinksCanvas('linksCanvas', nodes);
				var eventCan = new EventCanvas('eventCanvas', nodes, hoverCan, mainCan, linksCan, gridCan);

				console.log(mainCan);

				for (var i = 0; i < objects.length; i++) {
					var curObj = objects[i];

					if (parseInt(curObj.nodePosX) < minX)
						minX = curObj.nodePosX;
					if (parseInt(curObj.nodePosY) < minY)
						minY = curObj.nodePosY;
				}

				for (var i = 0; i < objects.length; i++) {
					var curObj = objects[i];
					if (!curObj.nodePosY)
						curObj.nodePosY = 0;
					if (!curObj.nodePosX)
						curObj.nodePosX = 0;
					curObj.nodePosY -= minY;
					curObj.nodePosX -= minX;
				}


				var links = [];
				for (var i = 0; i < objects.length; i++) {
					var curObj = objects[i];

					var inputs = [];
					var outputs = [];
					var x, y;
					var newNode;
					var nN;
					x = curObj.nodePosX;
					y = curObj.nodePosY;



					for (var j = 0; j < curObj.pins.length; j++) {
						var curPin = curObj.pins[j];
						var pinType = VAR_TYPES[curPin.pinSubType] && VAR_TYPES[curPin.pinSubType] || VAR_TYPES[curPin.pinType];
						if (curPin.bHidden === "True")
							continue;

						if (curPin.isOutput) {
							for (var k = 0; k < curPin.linkedTo.length; k++) {
								links.push({from: curPin.pinId, to: curPin.linkedTo[k]})
							}
						}
						var newPin = {name: curPin.pinFriendlyName && curPin.pinFriendlyName || curPin.pinText, type: pinType, id: curPin.pinId};
						if (curPin.isOutput) {
							outputs.push(newPin);
						}
						else {
							inputs.push(newPin);
						}
					}

					if (curObj.class.indexOf("K2Node_CallFunction") !== -1 || curObj.class.indexOf("K2Node_SpawnActorFromClass") !== -1 || curObj.class.indexOf("K2Node_GetInputAxisValue") !== -1) {
						if (curObj.class.indexOf("K2Node_SpawnActorFromClass") !== -1)
							curObj.nodeName = "Spawn Actor"
						newNode = {
							isPure: curObj.bIsPureFunc && curObj.bIsPureFunc === "True",
							name: curObj.nodeName,
							inputs: inputs,
							outputs: outputs
						};

						if (newNode.name.indexOf("Conv_") !== -1) {
							nN = new ConverterNode(newNode, x, y, mainCan, hoverCan);
						}
						else {
							nN = new FunctionNode(newNode, x, y, mainCan, hoverCan);
						}

					}
					else if (curObj.class.indexOf("K2Node_MacroInstance") !== -1 || curObj.class.indexOf("K2Node_IfThenElse") !== -1 || curObj.class.indexOf("K2Node_ExecutionSequence") !== -1) {
						if (curObj.class.indexOf("K2Node_IfThenElse") !== -1)
							curObj.nodeName = "Branch"
						else if (curObj.class.indexOf("K2Node_ExecutionSequence") !== -1)
							curObj.nodeName = "Sequence"
						newNode = {
							name: curObj.nodeName,
							inputs: inputs,
							outputs: outputs
						};

						nN = new MacroNode(newNode, x, y, mainCan, hoverCan);

					}
					else if (curObj.class.indexOf("K2Node_Event") !== -1 || curObj.class.indexOf("K2Node_CustomEvent") !== -1) {

						newNode = {
							name: curObj.nodeName,
							inputs: inputs,
							outputs: outputs,
							isCustom: curObj.isCustom
						};

						nN = new EventNode(newNode, x, y, mainCan, hoverCan);

					}
					else if (curObj.class.indexOf("K2Node_VariableGet") !== -1 || curObj.class.indexOf("K2Node_Self") !== -1) {
						newNode = {
							outputs: outputs
						};


						nN = new GetterNode(newNode, x, y, mainCan, hoverCan);

					}
					else if (curObj.class.indexOf("Set") !== -1) {
						newNode = {
							outputs: outputs,
							inputs: inputs
						};
						nN = new SetterNode(newNode, x, y, mainCan, hoverCan);
					}
					else if (curObj.class.indexOf("Operator") !== -1) {
						newNode = {
							name: curObj.nodeName,
							inputs: inputs,
							outputs: outputs
						};
						nN = new BinaryOperatorNode(newNode, x, y, mainCan, hoverCan);
					}

					nodes.push(nN);
				}
				for (var i = 0; i < links.length; i++) {
					var curLink = links[i];
					var from = null;
					var to = null;
					var nodeFrom = null;
					for (var j = 0; j < nodes.length; j++) {
						if (nodes[j].outputs) {
							for (var k = 0; k < nodes[j].outputs.length; k++) {
								if (nodes[j].outputs[k].id === curLink.from) {
									from = nodes[j].outputs[k];
									nodeFrom = nodes[j];
									break;
								}
							}
						}
						if (nodes[j].inputs) {
							for (var k = 0; k < nodes[j].inputs.length; k++) {
								if (nodes[j].inputs[k].id === curLink.to) {
									to = nodes[j].inputs[k];
									break;
								}
							}
						}
					}
					nodeFrom.setOutputLink(from, to);

				}



				//var getterNode = new GetterNode({name: "My Rotator huetator mukla", type: VAR_TYPES.rotator}, 1200, 17);
				//nodes.push(getterNode);



				gridCan.drawGrid();

				mainCan.draw();

				linksCan.drawLinks();
				globalStack.addCanvas(mainCan);
				globalStack.addCanvas(hoverCan);
				globalStack.addCanvas(gridCan);
				globalStack.addCanvas(linksCan);
				globalStack.addCanvas(eventCan);
			}

			function parse(text) {
				var parser = new BPParser(text);
				objects = parser.parseText();
				draw();
			}
		</script>
		<div id="svgContainer"></div>
		<div id="tmpSvgContainer"></div>
	</body>




</html>
